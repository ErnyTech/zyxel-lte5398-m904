Index: bridge-utils-1.1/brctl/brctl_cmd.c
===================================================================
--- bridge-utils-1.1.orig/brctl/brctl_cmd.c	2005-03-17 03:18:33.000000000 +0800
+++ bridge-utils-1.1/brctl/brctl_cmd.c	2019-05-28 19:09:22.781002608 +0800
@@ -375,8 +375,14 @@
 	}
 
 	qsort(fdb, offset, sizeof(struct fdb_entry), compare_fdbs);
-
+#if defined(ZYXEL_PATCH)
+	printf("port no\tmac addr\t\tis local?\tageing timer\tifname\n");
+#else
 	printf("port no\tmac addr\t\tis local?\tageing timer\n");
+#endif
+#if defined(ZYXEL_PATCH)
+	char ifName[IFNAMSIZ];
+#endif
 	for (i = 0; i < offset; i++) {
 		const struct fdb_entry *f = fdb + i;
 		printf("%3i\t", f->port_no);
@@ -385,6 +391,12 @@
 		       f->mac_addr[3], f->mac_addr[4], f->mac_addr[5]);
 		printf("%s\t\t", f->is_local?"yes":"no");
 		br_show_timer(&f->ageing_timer_value);
+#if defined(ZYXEL_PATCH)		
+		ifName[0] = 0;
+		if(!get_ifname(brname, f->port_no, ifName)){
+			printf("\t\t%s", ifName);
+		}
+#endif
 		printf("\n");
 	}
 	return 0;
Index: bridge-utils-1.1/libbridge/libbridge.h
===================================================================
--- bridge-utils-1.1.orig/libbridge/libbridge.h	2019-05-28 14:26:52.628180595 +0800
+++ bridge-utils-1.1/libbridge/libbridge.h	2019-05-28 19:09:59.940609699 +0800
@@ -110,4 +110,7 @@
 			    int path_cost);
 extern int br_read_fdb(const char *br, struct fdb_entry *fdbs, 
 		       unsigned long skip, int num);
+#if defined(ZYXEL_PATCH)
+extern int get_ifname(const char *brname, int portno, char *ifname);
+#endif
 #endif
Index: bridge-utils-1.1/libbridge/libbridge_devif.c
===================================================================
--- bridge-utils-1.1.orig/libbridge/libbridge_devif.c	2006-02-02 01:58:00.000000000 +0800
+++ bridge-utils-1.1/libbridge/libbridge_devif.c	2019-05-28 19:10:57.437437431 +0800
@@ -125,6 +125,29 @@
 	return -1;
 }
 
+#if defined(ZYXEL_PATCH)
+int get_ifname(const char *brname, int portno, char *ifname)
+{
+	int ifindices[MAX_PORTS];
+	unsigned long args[4] = { BRCTL_GET_PORT_LIST,
+				  (unsigned long)ifindices, MAX_PORTS, 0 };
+	struct ifreq ifr;
+
+	memset(ifindices, 0, sizeof(ifindices));
+	strncpy(ifr.ifr_name, brname, IFNAMSIZ);
+	ifr.ifr_data = (char *) &args;
+
+	if (ioctl(br_socket_fd, SIOCDEVPRIVATE, &ifr) < 0) {
+		dprintf("get_portno: get ports of %s failed: %s\n",
+			brname, strerror(errno));
+		return -1;
+	}
+
+	if_indextoname(ifindices[portno], ifname);
+	return 0;
+}
+#endif
+
 /* get information via ioctl */
 static int old_get_bridge_info(const char *bridge, struct bridge_info *info)
 {
